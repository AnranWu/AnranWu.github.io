---
layout: post
title: leetcode-3 无重复字符的最长子串
subtitle:
categories: leetcode
tags: [滑动窗口, 哈希表]
---

## 题目来源
[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

## 题目大意
给定一个字符串`s`，要求找出其中不含有重复字符的最长子串的长度。

## 解题思路及复杂度分析
### 问题分析
题目要求找出一个字符串中不含有重复字符的最长子串的长度。这个问题的关键在于如何高效地判断一个子串是否包含重复字符，并且如何快速地找到最长的这样的子串。

#### 暴力解法
最直接的想法是枚举字符串的所有子串，然后检查每个子串是否包含重复字符。这种方法的时间复杂度是\(O(n^3)\)，其中\(n\)是字符串的长度。具体来说：
1. 枚举所有可能的子串起点和终点，时间复杂度为\(O(n^2)\)。
2. 对于每个子串，检查是否包含重复字符，时间复杂度为\(O(n)\)。

显然，这种方法在字符串较长时效率非常低，不可行。

### 优化思路
为了提高效率，我们需要一种更高效的方法来判断子串是否包含重复字符，并且能够快速更新最长子串的长度。

#### 滑动窗口
滑动窗口是一种常用的优化方法，适用于处理子串或子数组问题。其核心思想是通过维护一个动态的窗口来覆盖目标子串或子数组，并且在窗口移动过程中高效地更新相关信息。

1. **窗口的定义**：定义一个滑动窗口，其左右边界分别为`st`和`ed`，表示当前考虑的子串范围。
2. **窗口的移动**：从左到右遍历字符串，逐步扩展窗口的右边界`ed`，同时检查当前窗口内的子串是否包含重复字符。
3. **重复字符的处理**：如果发现重复字符，需要将窗口的左边界`st`移动到重复字符的下一个位置，以保证窗口内的子串不包含重复字符。

#### 如何快速判断重复字符
为了快速判断一个字符是否在当前窗口内，可以使用一个哈希表（或数组）来记录每个字符最后一次出现的位置。这样，我们可以在常数时间内判断一个字符是否在当前窗口内，并且能够快速更新窗口的左边界。

### 算法步骤
1. **初始化**：
   - 创建一个大小为300的数组`pos`，用于记录每个字符最后一次出现的位置，初始化为0。
   - 初始化滑动窗口的左右边界`st`和`ed`，以及最长子串的长度`maxx`。
2. **遍历字符串**：
   - 对于每个字符`s.charAt(i)`，检查其是否在当前窗口内出现过（即`pos[s.charAt(i)]`是否大于`st`）。
   - 如果出现过，则将窗口的左边界`st`移动到该字符上次出现的位置之后。
   - 如果没有出现过，则更新最长子串的长度`maxx`。
3. **更新字符位置**：
   - 将当前字符的位置记录到`pos`数组中。

### 为什么这种方法可行
1. **滑动窗口的高效性**：通过滑动窗口，我们只需要遍历字符串一次，时间复杂度为\(O(n)\)。
2. **哈希表的快速查找**：使用哈希表（或数组）记录字符位置，可以在常数时间内判断一个字符是否在当前窗口内，进一步提高了效率。
3. **动态更新窗口**：通过动态调整窗口的左右边界，我们能够高效地找到所有不包含重复字符的子串，并且能够快速更新最长子串的长度。

### 时间复杂度分析
- 遍历字符串一次，时间复杂度为\(O(n)\)，其中\(n\)是字符串的长度。

### 空间复杂度分析
- 使用了一个大小为300的数组`pos`来记录字符位置，空间复杂度为\(O(1)\)。

## 代码
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int[] pos = new int[300]; // 用于记录每个字符最后一次出现的位置
        int st = 0, ed = 0, maxx = 0; // 滑动窗口的左右边界和最长子串长度
        for (int i = 0; i < s.length(); i++) {
            if (pos[s.charAt(i)] != 0 && pos[s.charAt(i)] > st) {
                // 如果字符在当前窗口内出现过，更新左边界
                st = pos[s.charAt(i)];
            }
            else {
                // 更新最长子串长度
                maxx = Math.max(maxx, ed - st + 1);
            }
            ed++; // 右边界向右移动
            pos[s.charAt(i)] = i + 1; // 更新字符的位置
        }
        return maxx; // 返回最长子串的长度
    }
}
```

## 题目标签

- 滑动窗口
- 哈希表